
---

# ✅ ADR-001 — **Por que começar com uma arquitetura simples e acoplada**

# ADR-001 — Arquitetura Inicial Simples e Acoplada

## Decisão

A primeira versão do sistema (Fase 1) será construída de forma **intencionalmente simples, acoplada e monolítica**, concentrando toda a lógica em um único arquivo Go e utilizando apenas o mínimo necessário para:

- receber um PDF via upload
- abrir o PDF
- extrair texto
- contar palavras
- retornar o resultado

Sem camadas.  
Sem interfaces.  
Sem padrões.  
Sem estrutura modular.

---

## Contexto

Ao iniciar um projeto complexo como um sistema de análise assíncrona com filas, worker pool, camadas de domínio, adapters e boas práticas arquiteturais, existe um risco real:

**Construir uma arquitetura sofisticada cedo demais, sem validar a parte mais crítica: a extração de PDF.**

Por experiência, sistemas ficam “bonitos por fora e quebrados por dentro” quando:

- se abstrai cedo demais  
- se cria interface sem saber ainda o contrato real  
- se planeja storage, worker pool e patterns prematuramente  
- se investe em acoplamento baixo antes de validar o funcionamento mínimo  

Além disso, este projeto tem objetivo didático: mostrar a **evolução clara** entre:

1. solução ingênua (Fase 1),
2. organização inicial (Fase 2),
3. arquitetura limpa (Fase 3),
4. sistema robusto assíncrono (Fase 4).

A diferença entre *“ruim que funciona”* e *“bom que evolui”* só é visível quando existe um ponto de partida simples.

---

## Justificativa

1. **Reduzir incerteza técnica**  
   Antes de investir em arquitetura, precisamos validar:
   - biblioteca de PDF usada,
   - desempenho,
   - qualidade da extração,
   - custo de parsing,
   - memória e tempo de CPU.

2. **Aprendizado progressivo**  
   A pedagogia do projeto depende de mostrar:
   - más práticas,
   - gargalos,
   - problemas clássicos de acoplamento,
   - refatorações necessárias.

   Isso prepara terreno para justificar a arquitetura limpa — não como “moda”, mas como **resposta a dores reais**.

3. **Evitar over-engineering**  
   Começar com hexagonal architecture antes de validar a lógica básica seria falso e artificial.

4. **Material para entrevistas**  
   Mostrar a evolução do código é mais poderoso que entregar apenas o final bonito:
   - prova maturidade,
   - prova habilidade de refatoração,
   - prova entendimento de motivos e trade-offs.

---

## Consequências

### Consequências positivas:
- Entrega rápida de algo funcional.
- Feedback imediato da parte crítica (extração PDF).
- Facilita explicar a evolução arquitetural posteriormente.
- Evita abstrações prematuras.
- Mantém complexidade baixa no início.

### Consequências negativas (aceitas de propósito):
- Código sujo.
- Sem testes.
- Lógica acoplada.
- Difícil escalar a Fase 1 diretamente.
- Não é reutilizável.

Essas consequências são **intencionais** porque servem de base para as fases seguintes.

---

## Status

**Aprovado — Implementação na Fase 1.**

---

## Próximos passos

- Criar `main.go` simples.
- Implementar rota `/analyze`.
- Extrair texto e contar palavras.
- Depois registrar ADR-002 para justificar a primeira refatoração.
