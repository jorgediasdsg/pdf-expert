# ADR-017 — Introduce Domain and DTO Validation Rules

## Status
Accepted

## Context
The system currently accepts any uploaded file and any input path, assuming
that downstream components will handle invalid states. This approach is risky
and creates hidden failure modes.

In Clean Architecture, validation must follow the Dependency Rule:

- **DTO validation**: Ensures external input is well-formed before entering the application layer.
- **Domain validation**: Ensures domain invariants are respected and invalid states cannot exist inside the core of the system.

This creates defensive boundaries that prevent:
- invalid file paths,
- nonexistent files,
- empty inputs,
- meaningless domain objects.

## Decision
Implement a **two-tier validation system**:

### 1. DTO Validation
Performed at application boundary (`dto` package).
Ensures:
- the input has the required fields,
- file path is not empty,
- input satisfies minimum shape for processing.

### 2. Domain Validation
Performed inside `domain` types and constructors.
Ensures:
- domain invariants,
- domain cannot represent invalid states.

### 3. Validation errors
Introduce:
- `ErrInvalidInput`
- `ErrDomainViolation`

These errors are *domain-meaningful* and not tied to HTTP.

Handlers map them to HTTP responses.

## Consequences

### Positive
- Invalid states are caught early.
- Domain cannot be corrupted.
- Use cases remain clean and predictable.
- Handlers become more robust.
- Framework errors stay outside the domain.

### Negative
- Requires more files (DTO, domain errors).
- Need mapping between domain errors and HTTP responses.

## Alternatives

### A) Validate only in handlers
Rejected — couples HTTP to rules, breaks hexagonal separation.

### B) Validate only in use cases
Rejected — use cases become bloated and domain can still be corrupted.

### C) Skip validation entirely
Rejected — unacceptable for production-bound architecture.
