# ADR-013 — Introduce the Domain Layer

## Status
Accepted

## Context
The system started as a simple PDF processing API, and the business logic lived inside HTTP handlers or inside infrastructure code.  
To evolve the project into a maintainable architecture, we must isolate the business concepts that define the system.

Go projects often mix infrastructure details with domain logic, which causes:
- high coupling,
- harder testing,
- difficulty replacing components,
- inability to grow safely.

To move toward Clean Architecture, the domain must become an independent and pure layer.

## Decision
Create a `internal/domain` package containing domain entities, starting with:

- `AnalysisResult` — the domain-level representation of PDF analysis.

This package:
- depends on no external library,
- has no knowledge of HTTP, JSON, adapters, files, or frameworks,
- represents the “business rules” of the system.

## Consequences

### Positive
- Domain becomes explicit and stable.
- The rest of the system becomes replaceable.
- Improves testability and maintainability.
- Enables the introduction of use cases without coupling to external concerns.

### Negative
- Requires mapping between domain types and adapter types.
- Initial refactor adds complexity (but pays off as system grows).

## Alternatives
A) Keep domain logic inside handlers  
Rejected — this leads to unmaintainable code as features grow.

B) Place domain types inside app/usecase  
Rejected — application logic should orchestrate behavior, not define the domain.
