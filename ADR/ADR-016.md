# ADR-016 — Introduce Formal DTOs for Application Layer Boundaries

## Status
Accepted

## Context
Until now, the AnalyzePDFUseCase used a simple Go struct as input and output.
While functional, this structure is implicitly tied to the handler and lacks:

- explicit definition of external vs internal data
- evolution safety
- semantic clarity
- standardized transformations at the application boundary
- validation capability (when needed)

As features expand (metadata extraction, OCR, summaries, embeddings), the 
application layer will need strict contracts to avoid coupling to HTTP or
infrastructure concerns.

DTOs (Data Transfer Objects) are the standard mechanism used in Clean 
Architecture to represent **application boundary contracts**.

## Decision
Introduce **formal DTOs** for all use cases.

For AnalyzePDFUseCase:

### Input DTO
- `AnalyzePDFInputDTO`  
Represents what the application layer needs to perform its logic.

### Output DTO
- `AnalyzePDFOutputDTO`  
Represents the data the application layer returns, isolated from domain and HTTP.

DTOs live under:

internal/app/dto/


They must:
- be independent from HTTP (Gin)  
- be independent from domain internals  
- act as stable contracts between layers  

## Consequences

### Positive
- Clear separation between input/output shapes and domain logic.
- Improved maintainability and readability.
- DTOs act as an evolution barrier (API changes don't break domain).
- Convenient validation entry point (future).
- Enables multiple adapters (HTTP, CLI, gRPC, queues) using the same use case.

### Negative
- Adds more files (but reduces hidden complexity).
- Requires mapping between domain → dto and dto → domain.

## Alternatives

1. Use domain types directly in handlers and use cases  
Rejected — couples domain to infrastructure adapters.

2. Use generic maps or interface{}  
Rejected — makes code fragile, untyped, harder to test.

