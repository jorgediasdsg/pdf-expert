# ADR-011 — Introduce centralized configuration in internal/config

## Status
Accepted

## Context
Before this change, configuration values such as:

- HTTP port,
- environment (dev/prod),
- temporary folder path,

were either hard-coded or scattered across different parts of the code.  
This makes it harder to:

- run the service in different environments,
- change behavior without touching code,
- reason about which configuration values exist and how they are used.

As the project moves toward a more structured architecture (Phase 3), a centralized configuration mechanism becomes essential.

## Decision
Introduce a `Config` struct and a `Load` function under `internal/config`:

- `Config` holds the main configuration values:

    - `Env` (e.g., dev, prod),
    - `HTTPPort`,
    - `TempFolder`.

- `Load()` reads from environment variables with sensible defaults:

    - `APP_ENV` → default `dev`,
    - `HTTP_PORT` → default `8080`,
    - `TEMP_FOLDER` → default `./tmp`.

The `cmd/api/main.go` entrypoint loads the configuration once and passes it down where needed (e.g., to HTTP or file handling logic).

## Consequences

### Positive
- Centralized configuration model (single place to look at).
- Easy to adjust behavior via environment variables.
- Future configuration options (timeouts, logging levels, feature flags) have a clear home.
- Prepares the codebase for Phase 3, where the application layer can depend on configuration in a controlled way.

### Negative
- Slight additional indirection (must call `config.Load()` instead of using hard-coded values).
- If misused, components may start calling `Load()` directly rather than receiving configuration via dependency injection (this can be refined in Phase 3).

## Alternatives

1. Keep configuration inline / hard-coded  
   Rejected: scales poorly and makes environment-specific behavior harder to manage.

2. Use a third-party configuration library  
   Rejected for this stage: the current needs are modest, and a simple, explicit solution is enough. Third-party libraries can be considered later if configuration complexity increases.